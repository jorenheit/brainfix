#ifndef BFXFUNCTION_H
#define BFXFUNCTION_H

#include <vector>
#include <string>
#include <cassert>
#include "instruction.h"

class BFXFunction
{
public:   
    enum class ParameterType
        {
         Value,
         Reference
        };

    using Parameter = std::pair<std::string, ParameterType>;
    
private:
    std::string            d_name;
    Instruction            d_body;
    std::vector<Parameter> d_params;
    std::string            d_returnVar;
    std::string            d_mangled;

public:
    BFXFunction()
    {
        assert(false && "Default constructor shouldn't be called.");
        
        // Default constructor must be declared for some reason
        // to be compatible with the CompilerBase class generated by
        // bisonc++, but is never actually called (and shouldn't be).
    }

    BFXFunction(std::string name, std::vector<Parameter> const &params):
        d_name(name),
        d_params(params),
        d_mangled(mangle(name, params.size()))
    {}

    BFXFunction &setBody(Instruction const &body)
    {
        d_body = body;
        return *this;
    }
    
    BFXFunction &setReturnVariable(std::string const &ident)
    {
        d_returnVar = ident;
        return *this;
    }

    Instruction const &body() const
    {
        return d_body;
    }

    std::vector<Parameter> const &params() const
    {
        return d_params;
    }

    std::string const &returnVariable() const
    {
        return d_returnVar;
    }

    std::string const &name() const
    {
        return d_name;
    }

    std::string const &mangled() const
    {
        return d_mangled;
    }
    
    bool isVoid() const
    {
        return d_returnVar.empty();
    }

public:
    static std::string mangle(BFXFunction const &func)
    {
        return mangle(func.name(), func.params().size());
    }

    
    static std::string mangle(std::string const &name, int const nArgs)
    {
        return std::string("__f_") + std::to_string(nArgs) + "_" + name;
    }
};

#endif 
